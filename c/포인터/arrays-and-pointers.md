---
layout: wiki
title: 배열과 포인터
wiki_name: c
parent: c/포인터
order: 5
---

## 배열과 포인터

C언어에서 **배열과 포인터는 거의 같은 개념처럼 동작**한다.

정확히 말하면,

배열 이름은 배열의 첫 번째 요소의 주소이다.

이 한 줄이 전부의 시작이다.

---

### 배열 이름의 정체

```c
int arr[5] = {10, 20, 30, 40, 50};
```

이때

* `arr`  → `&arr[0]` 과 동일
* `arr`  → 배열의 **시작 주소**
* 값이 아니라 **주소**다

```c
printf("%d\n", arr[0]);
printf("%d\n", *arr);
```

출력:

```
10
10
```

✔️ `arr[0] == *arr`

---

### 배열 접근 방식 비교

```c
arr[i]
*(arr + i)
```

두 개는 **완전히 같은 의미**

예시:

```c
printf("%d\n", arr[2]);
printf("%d\n", *(arr + 2));
```

출력:

```
30
30
```

---

### 왜 arr + 1 이 가능한가?

```c
arr + 1
```

이건 “주소 + 1바이트”가 아니다 ❌
**자료형 크기만큼 이동**한다.

```c
int arr[5];
```

* `arr + 1` → 다음 int 요소
* 실제 이동량 → `sizeof(int)` 바이트

포인터 연산은 **타입 기준**이다 (개중요)

---

### 포인터로 배열 다루기

```c
int arr[3] = {1, 2, 3};
int *p = arr;
```

이제 완전히 같은 동작:

```c
p[0] == arr[0]
*(p + 1) == arr[1]
```

출력 예:

```c
printf("%d\n", p[2]);   // 3
printf("%d\n", *(p+2)); // 3
```

---

### 배열 이름 vs 포인터 변수 차이 (중요❗)

```c
int arr[5];
int *p = arr;
```

공통점:

* 둘 다 주소처럼 사용 가능
* 인덱싱 가능

차이점:

| 항목   | 배열 이름     | 포인터        |
| ---- | --------- | ---------- |
| 값 변경 | ❌ 불가능     | ⭕ 가능       |
| 의미   | 고정된 시작 주소 | 주소를 저장한 변수 |

```c
arr = p; // ❌ 에러
p = arr; // ⭕ 가능
```

---

### 함수에서 배열 전달 = 포인터 전달

```c
void print(int *p) {
    printf("%d\n", p[0]);
}

int main() {
    int arr[3] = {10, 20, 30};
    print(arr);
}
```

배열을 넘긴 것 같지만

실제로는 **첫 요소의 주소**가 넘어간다

✔️ 그래서 C 함수에서 배열 크기를 직접 알 수 없다

---

### 배열 크기 못 구하는 이유

```c
void func(int arr[]) {
    sizeof(arr); // 포인터 크기
}
```

함수 안에서 배열은:

```
int arr[] → int *arr
```

으로 바뀐다.

그래서 항상 길이를 같이 넘긴다:

```c
void func(int arr[], int size)
```
