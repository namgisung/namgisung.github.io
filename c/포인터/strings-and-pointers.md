---
layout: wiki
title: 문자열과 포인터
wiki_name: c
parent: c/포인터
order: 6
---

## 문자열과 포인터

C언어에서 문자열은 **특별한 타입이 아니다.**

문자열은 char 배열이고, 문자열 처리는 포인터 기반이다.

---

### 문자열의 본질

C에서 문자열은 다음 조건을 만족하는 **char 배열**이다.

✔️ `char` 타입

✔️ 마지막에 반드시 `'\0'` (널 문자)로 끝남

```c
char str[] = "Hello";
```

실제 메모리 구조:

```
'H' 'e' 'l' 'l' 'o' '\0'
```

---

### 문자열 선언 방법 2가지

#### (1) 배열로 선언

```c
char str[] = "Hello";
```

특징:

* 배열
* 문자열 내용 변경 가능
* 메모리에 직접 저장

```c
str[0] = 'h'; // 가능
```

---

#### (2) 포인터로 선언

```c
char *str = "Hello";
```

특징:

* 문자열 리터럴을 가리키는 포인터
* 문자열 변경 ❌ (위험)

```c
str[0] = 'h'; // ❌ 런타임 오류 가능
```

이유:

문자열 리터럴 `"Hello"`는 **읽기 전용 영역**에 저장된다.

---

### 배열 vs 포인터 문자열 차이 (중요❗)

| 구분    | char 배열 | char 포인터 |
| ----- | ------- | -------- |
| 저장 위치 | 스택/전역   | 읽기 전용 영역 |
| 내용 변경 | ⭕ 가능    | ❌ 위험     |
| 주소 값  | 고정      | 변경 가능    |

```c
char a[] = "Hi";
char *b = "Hi";

b = "Hello"; // ⭕ 가능
a = "Hello"; // ❌ 불가능
```

---

### 문자열과 포인터의 관계

```c
char str[] = "ABC";
```

이때:

```c
str        // &str[0]
*str       // 'A'
*(str+1)   // 'B'
str[2]     // 'C'
```

✔️ 문자열은 **포인터 연산의 교과서 예제**

---

### 문자열 출력 원리

```c
printf("%s", str);
```

printf는 내부적으로:

1. 주소를 받음
2. 그 주소부터 char 하나씩 읽음
3. `'\0'` 만날 때까지 출력

그래서:

```c
printf("%s", str + 1);
```

출력:

```
ello
```

---

### 문자열은 반드시 '\0'이 필요하다

```c
char str[3] = {'A', 'B', 'C'};
printf("%s", str); // ❌ undefined behavior
```

❌ 문자열 아님

❌ 끝을 알 수 없음

올바른 예:

```c
char str[4] = {'A', 'B', 'C', '\0'};
```

---

### <string.h> 와 문자열 처리

```c
#include <string.h>
```

이 헤더는 **문자열 전용 함수 모음**이다.

| 함수     | 설명               |
| ------ | ---------------- |
| strlen | 문자열 길이           |
| strcpy | 문자열 복사           |
| strcat | 문자열 이어붙이기        |
| strcmp | 문자열 비교           |
| strtok | 문자열 분리(split 역할) |

예:

```c
char s[] = "Hello";
printf("%lu", strlen(s)); // 5
```

✔️ 배열을 직접 다루는 건 위험

✔️ 그래서 표준 함수 사용 권장
